<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Firebase CDN (app + database) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<title>Horse Race Quiz ‚Äî Field + Early Confetti + Podium</title>
<style>
  :root{
    --bg:#0c1220; --card:#131a2e; --ink:#e9f0ff; --muted:#9aa4bf; --edge:#22315c;
    --ok:#33d17a; --bad:#ff6b6b; --acc:#6ac2ff; --gold:#ffd36a;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--ink); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}

  /* Race area takes 75% of screen */
  .raceTop{height:75vh; min-height:480px; position:relative; border-bottom:1px solid var(--edge)}
  canvas#raceCanvas{position:absolute; inset:0; width:100%; height:100%}

  .hud{
    position:absolute; left:12px; top:10px; display:flex; gap:8px; flex-wrap:wrap;
    background:rgba(15,21,39,.5); border:1px solid var(--edge); backdrop-filter:blur(6px);
    padding:6px 8px; border-radius:8px; font-size:11px; z-index:5;
  }
  .hud .pill{padding:2px 6px; border-radius:999px; font-size:11px; background:#0f1527; border:1px solid var(--edge); color:var(--muted)}
  .hud .title{font-weight:800}
  .hudRight{position:absolute; right:12px; top:10px; display:flex; gap:8px; align-items:center; font-size:12px; z-index:5;}
  .clock{font-variant-numeric:tabular-nums; font-weight:800}
  .btnTiny{cursor:pointer; border:1px solid var(--edge); background:#0f1527; color:var(--ink); padding:4px 6px; border-radius:6px; font-weight:600; font-size:11px}

  /* Compact controls */
  .bottom{max-width:1100px; margin:12px auto; padding:0 12px 12px}
  .card{background:var(--card); border:1px solid var(--edge); border-radius:10px; padding:10px}
  .row{display:flex; align-items:center; gap:8px; margin:6px 0}
  label{font-size:13px;color:var(--muted)}
  input[type="text"],input[type="number"]{background:#0f1527; color:var(--ink); border:1px solid var(--edge); border-radius:6px; padding:4px 6px; font-size:13px}
  input[type="text"]{width:120px} input[type="number"]{width:70px}
  .btn{cursor:pointer; border:1px solid var(--edge); background:#0f1527; color:var(--ink); padding:6px 8px; border-radius:8px; font-weight:600; font-size:13px}
  .btn.good{border-color:#245c43; background:#0c1a16}
  .btn.warn{border-color:#5c2424; background:#1a0c0c}
  .btn.accent{border-color:#274f7c; background:#0d1626}
  .btn.gold{border-color:#7c6a27; background:#1a1506; color:var(--gold)}
  .playersGrid{display:grid; grid-template-columns: 1fr auto auto; gap:6px 10px; align-items:center; margin-top:6px}
  .tiny{font-size:11px; color:var(--muted)}
  .warning{color:var(--bad); font-weight:600; display:none; font-size:12px}
  .perRound{margin-top:8px; border-top:1px dashed var(--edge); padding-top:8px}
  .perRound h3{margin:0 0 6px; font-size:14px}
  .perRound .grid{display:grid; grid-template-columns: 1fr 70px 70px; gap:6px 10px; align-items:center}
  .footerBtns{display:flex; gap:6px; margin-top:8px; flex-wrap:wrap}

  /* Podium overlay */
  .overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(9,13,25,.65); backdrop-filter: blur(6px); z-index:20;
  }
  .overlay.show{display:flex}
  .podium{
    position:relative; background:#0f1527; border:1px solid var(--edge);
    border-radius:14px; padding:16px 18px; width:min(680px, 92vw);
    box-shadow:0 10px 40px rgba(0,0,0,.35);
  }
  .podium h2{margin:0 0 8px; font-size:20px}
  .podium .stage{display:flex; gap:10px; align-items:flex-end; justify-content:center; margin-top:10px}
  .plinth{border:1px solid var(--edge); background:#0c1529; border-radius:10px 10px 6px 6px; width:30%; text-align:center; padding:8px 6px}
  .plinth .place{font-size:22px; font-weight:900}
  /* Bigger, black names */
  .plinth .name{margin-top:4px; font-size:20px; font-weight:900; color:#000 !important}
  .p1{height:180px; background:linear-gradient(#ffe8a6,#ffd36a); color:#1a1400}
  .p2{height:150px; background:linear-gradient(#e8edf5,#cfd8e6); color:#0e1218}
  .p3{height:130px; background:linear-gradient(#ffd9b3,#ffb873); color:#241200}
  .podium .actions{display:flex; justify-content:center; gap:10px; margin-top:12px}
  .podium .actions .btn{font-size:13px}

  /* Confetti canvas */
  #confettiCanvas{position:fixed; inset:0; pointer-events:none; z-index:19; display:none;}
  #confettiCanvas.show{display:block;}
</style>
</head>
<body>

<!-- TOP: animated race -->
<div class="raceTop">
  <canvas id="raceCanvas"></canvas>

  <div class="hud">
    <span class="title">üêé Horse Race</span>
    <span id="roundHud" class="pill">Round 1/30</span>
    <span class="pill">Correct = +1</span>
    <span class="pill">Fastest correct = +1</span>
  </div>
  <div class="hudRight">
    <label class="tiny">Round timer (s)</label>
    <input id="secsTop" type="number" min="5" max="300" value="20" />
    <button class="btnTiny" id="startTimerTop">Start (T)</button>
    <button class="btnTiny" id="stopTimerTop">Stop</button>
    <div class="clock" id="clockTop">00:20</div>
  </div>
</div>

<!-- BOTTOM: controls/scoring -->
<div class="bottom">
  <div class="card">
    <div class="row">
      <label>Total rounds</label>
      <input id="totalRounds" type="number" min="1" max="100" value="30">
      <button class="btn accent" id="applyRounds">Apply</button>
      <span class="tiny">Keys: <strong>1‚Äì7</strong> fastest (+correct), <strong>Shift+1‚Äì7</strong> toggle correct, <strong>Space</strong> Apply, <strong>Backspace</strong> Undo, <strong>R</strong> Reset, <strong>T</strong> Timer.</span>
    </div>

    <div class="row"><label>Player names</label></div>
    <div class="playersGrid" id="nameGrid"></div>

    <div class="perRound">
      <h3>Round Input</h3>
      <div class="tiny">Tick everyone who was <strong>correct</strong>. Select <strong>fastest</strong> among them. Then Apply.</div>
      <div class="grid" id="roundGrid"></div>
      <div class="warning" id="warn">Fastest must be one of the correct players (or leave fastest blank).</div>
      <div class="footerBtns">
        <button class="btn good" id="applyRound">Apply Round (Space)</button>
        <button class="btn" id="undoRound" disabled>Undo (Backspace)</button>
        <button class="btn warn" id="resetRace">Reset Race (R)</button>
        <button class="btn gold" id="exportCsv">Export CSV</button>
      </div>
    </div>
  </div>
</div>

<!-- SINGLE-PAGE PLAYER VIEW (hidden unless ?role=player) -->
<div class="bottom" id="playerView" style="display:none">
  <div class="card">
    <div class="row" style="flex-wrap:wrap; gap:10px">
      <label>Room</label><input id="pvRoom" placeholder="2468" />
      <label>Name</label><input id="pvName" placeholder="Your name" />
      <button class="btn accent" id="pvJoin">Join</button>
      <span class="pill" id="pvStatus">Idle</span>
    </div>
  </div>

  <div class="card" id="pvQuestion" style="display:none; margin-top:10px">
    <div class="row" style="flex-wrap:wrap; gap:10px">
      <strong id="pvQIndex">Q ‚Äî</strong> <span id="pvStem">‚Äî</span>
      <span class="pill">Time left: <span id="pvClock">‚Äî</span></span>
    </div>
    <div class="row" style="flex-wrap:wrap; gap:8px; margin-top:8px">
      <button class="btn" id="pvC0" data-i="0">A</button>
      <button class="btn" id="pvC1" data-i="1">B</button>
      <button class="btn" id="pvC2" data-i="2">C</button>
      <button class="btn" id="pvC3" data-i="3">D</button>
      <span class="pill" id="pvSubmitted">No answer yet</span>
    </div>
  </div>
</div>

  
<!-- Podium + confetti -->
<canvas id="confettiCanvas"></canvas>
<div id="podiumOverlay" class="overlay" aria-hidden="true">
  <div class="podium" role="dialog" aria-modal="true" aria-labelledby="podiumTitle">
    <h2 id="podiumTitle">üèÜ Top 3 Finishers</h2>
    <div class="stage">
      <div class="plinth p2"><div class="place">ü•à 2nd</div><div class="name" id="podium2">‚Äî</div></div>
      <div class="plinth p1"><div class="place">ü•á 1st</div><div class="name" id="podium1">‚Äî</div></div>
      <div class="plinth p3"><div class="place">ü•â 3rd</div><div class="name" id="podium3">‚Äî</div></div>
    </div>
    <div class="actions">
      <button class="btn" id="closePodium">Close</button>
      <button class="btn gold" id="copyWinners">Copy winners</button>
    </div>
  </div>
</div>

<script>
(function(){
  /* =================== CONFIG & CONSTANTS =================== */
  const NUM_PLAYERS = 7;
  const INIT_NAMES  = ["Player 1","Player 2","Player 3","Player 4","Player 5","Player 6","Player 7"];

  // Field geometry
  const FIELD_TOP = 150, FIELD_BOTTOM_MARGIN = 40;
  const leftPad = 110, rightPad = 8;
  const FINISH_GAP_FROM_FENCE = 8;

  // Visuals
  const HORSE_EMOJI = 'üêé', EMOJI_SIZE = 44;
  const X_NEAR = 110, Y_SEP = 28, SPRING = 0.04, ITERATIONS = 2;

  
 // ======= Firebase (project config) =======
const firebaseConfig = {
  apiKey: "AIzaSyAJTVGllUlmanFga4-eCuSi5YucB8F42TQ",
  authDomain: "horserace-50cd0.firebaseapp.com",
  databaseURL: "https://horserace-50cd0-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "horserace-50cd0",
  storageBucket: "horserace-50cd0.firebasestorage.app",
  messagingSenderId: "942770888682",
  appId: "1:942770888682:web:57b899f682ae6397325c93",
  measurementId: "G-EZDCQ7G8SV"
};


  /* =================== STATE (RACE) =================== */
  const state = {
    totalRounds: 30,
    roundNow: 1,
    players: [],            // {name, pos, animX, y, baseY}
    history: [],            // [{idx, delta},...]
    finishOrderIdxs: [],
    podiumShown: false,
    confettiStarted: false
  };

  /* =================== DOM HOOKS (HOST) =================== */
  const elTotalRounds = document.getElementById('totalRounds');
  const elApplyRounds = document.getElementById('applyRounds');
  const elNameGrid = document.getElementById('nameGrid');
  const elRoundGrid = document.getElementById('roundGrid');
  const elWarn = document.getElementById('warn');
  const elApplyRound = document.getElementById('applyRound');
  const elUndo = document.getElementById('undoRound');
  const elReset = document.getElementById('resetRace');
  const elExport = document.getElementById('exportCsv');
  const elRoundHud = document.getElementById('roundHud');

  // Timer (host HUD)
  const elSecsTop = document.getElementById('secsTop');
  const elStartTop = document.getElementById('startTimerTop');
  const elStopTop  = document.getElementById('stopTimerTop');
  const elClockTop = document.getElementById('clockTop');
  let timerInt=null, remaining=0;

  // Auto Voting host controls
  const modeSelect = document.getElementById('modeSelect');
  const roomCodeEl = document.getElementById('roomCode');
  const createOrJoinRoom = document.getElementById('createOrJoinRoom');
  const openPlayerLink = document.getElementById('openPlayerLink');
  const autoStatus = document.getElementById('autoStatus');
  const questionPane = document.getElementById('questionPane');
  const qIndex = document.getElementById('qIndex');
  const qStem = document.getElementById('qStem');
  const optEls = [0,1,2,3].map(i=>document.getElementById('opt'+i));
  const voteClock = document.getElementById('voteClock');
  const forceLockBtn = document.getElementById('forceLock');
  const skipQBtn = document.getElementById('skipQ');

  // Player View (same page)
  const pv = {
    wrapper: document.getElementById('playerView'),
    room: document.getElementById('pvRoom'),
    name: document.getElementById('pvName'),
    join: document.getElementById('pvJoin'),
    status: document.getElementById('pvStatus'),
    card: document.getElementById('pvQuestion'),
    qIndex: document.getElementById('pvQIndex'),
    stem: document.getElementById('pvStem'),
    clock: document.getElementById('pvClock'),
    submitted: document.getElementById('pvSubmitted'),
    choices: [0,1,2,3].map(i=>document.getElementById('pvC'+i))
  };

  // Canvas + effects
  const canvas = document.getElementById('raceCanvas'), ctx = canvas.getContext('2d');
  let W=0,H=0,t=0,lastFrame=0;
  let baseScroll=140, scrollBoost=0, trackOffset=0;
  const finishLineX = ()=> W - rightPad, startLineX = ()=> leftPad;

  const overlay = document.getElementById('podiumOverlay');
  const podium1 = document.getElementById('podium1'), podium2 = document.getElementById('podium2'), podium3 = document.getElementById('podium3');
  const confetti = document.getElementById('confettiCanvas'), cctx = confetti.getContext('2d');
  let confettiRunning=false, confettiStart=0, confettiParts=[];
  const surged = new Set();

  /* =================== UTILS =================== */
  const clamp = (n,min,max)=> Math.min(max,Math.max(min,n));
  const fmt = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
  function mk(tag,cls,txt){ const el=document.createElement(tag); if(cls) el.className=cls; if(txt!=null) el.textContent=txt; return el; }

  // Small helper to ensure we have a UID (after anonymous sign-in)
  async function getUid(){
    // If already signed in, return current UID
    if (firebase.auth().currentUser) return firebase.auth().currentUser.uid;
    // Else wait for auth state
    await new Promise(resolve=>{
      const unsub = firebase.auth().onAuthStateChanged(u=>{ if(u){ unsub(); resolve(); } });
    });
    return firebase.auth().currentUser.uid;
  }

  /* =================== RACE UI (HOST) =================== */
  function buildNameEditor(){
    elNameGrid.innerHTML='';
    state.players.forEach((p,i)=>{
      const nameInput = document.createElement('input');
      nameInput.type='text'; nameInput.value=p.name;
      nameInput.addEventListener('input', e=> p.name = e.target.value || `Player ${i+1}`);
      const posPill = document.createElement('div'); posPill.className='tiny'; posPill.id=`posPill${i}`; posPill.textContent='Moves: 0';
      const seat = document.createElement('div'); seat.className='tiny'; seat.textContent = `Seat #${i+1}`;
      elNameGrid.append(nameInput,posPill,seat);
    });
  }
  function buildRoundInputs(){
    elRoundGrid.innerHTML='';
    const h1=mk('div','tiny','Player'), h2=mk('div','tiny','Correct'), h3=mk('div','tiny','Fastest');
    elRoundGrid.append(h1,h2,h3);
    state.players.forEach((p,i)=>{
      const nameCell=mk('div',null), correctCell=mk('div',null), fastestCell=mk('div',null);
      const c=mk('input'); c.type='checkbox'; c.id=`c${i}`;
      const f=mk('input'); f.type='radio'; f.name='fastest'; f.id=`f${i}`;
      const lab=mk('label',null,p.name); lab.htmlFor=`c${i}`; lab.id=`labC${i}`;
      nameCell.appendChild(lab); correctCell.appendChild(c); fastestCell.appendChild(f);
      elRoundGrid.append(nameCell,correctCell,fastestCell);
    });
    elRoundGrid.addEventListener('click', (e)=>{
      if(e.target && e.target.type==='radio'){
        e.target.dataset.toggled = e.target.dataset.toggled==='1' ? '0' : '1';
        if (e.target.dataset.toggled==='0') e.target.checked=false;
        [...document.querySelectorAll('input[name="fastest"]')].forEach(r=>{ if(r!==e.target) r.dataset.toggled='0'; });
      }
    });
  }
  function updateSidebar(){ state.players.forEach((p,i)=>{ const el=document.getElementById(`posPill${i}`); if(el) el.textContent=`Moves: ${p.pos}`; }); }
  function updateUndo(){ elUndo.disabled = state.history.length===0; }

  /* =================== RACE ENGINE =================== */
  function approach(cur,tgt,dt,speed){ const d=tgt-cur; return cur+Math.sign(d)*Math.min(Math.abs(d),speed*dt); }

  function resize(){
    const r = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(r.width  * devicePixelRatio);
    canvas.height = Math.floor(r.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    W=r.width; H=r.height;
    confetti.width  = Math.floor(r.width);
    confetti.height = Math.floor(r.height);
    layoutFieldY();
  }
  window.addEventListener('resize', resize);

  function fieldGeometry(){ const top=FIELD_TOP, bot=H-FIELD_BOTTOM_MARGIN, height=Math.max(60,bot-top); return {top,bot,height}; }
  function layoutFieldY(){
    const { top, height } = fieldGeometry();
    for(let i=0;i<state.players.length;i++){
      const base = top + ((i + 0.5) / NUM_PLAYERS) * height;
      const spread = height / NUM_PLAYERS * 0.35;
      const jitter = (Math.random()*2 - 1) * spread;
      const baseY = clamp(base + jitter, top + 24, top + height - 24);
      const p = state.players[i]; p.baseY=baseY; if (p.y == null) p.y = baseY;
    }
  }
  function resolveCrowding(){
    const { top, bot } = fieldGeometry(); const minY = top + 24, maxY = bot - 24;
    state.players.forEach(p=>{ p.y += (p.baseY - p.y) * SPRING; });
    for(let it=0; it<ITERATIONS; it++){
      for(let i=0;i<state.players.length;i++){
        for(let j=i+1;j<state.players.length;j++){
          const a = state.players[i], b = state.players[j];
          const dx = Math.abs(a.animX - b.animX); if (dx > X_NEAR) continue;
          const dy = b.y - a.y, ady = Math.abs(dy);
          if (ady < Y_SEP){
            const overlap = (Y_SEP - ady) * (1 - dx / X_NEAR); const dir = dy >= 0 ? 1 : -1;
            a.y -= overlap * 0.5 * dir; b.y += overlap * 0.5 * dir;
          }
        }
      }
      state.players.forEach(p=>{ p.y = clamp(p.y, minY, maxY); });
    }
  }
  function drawBackground(off){
    const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0f1836'); g.addColorStop(1,'#0b1329'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    const y=60; ctx.save(); ctx.globalAlpha=.35; ctx.fillStyle='#0b1e35'; for(let x=-W; x<W*2; x+=160){ ctx.fillRect(Math.floor(x-off*.18), y, 120, 30);} ctx.restore();
    const fy=120; ctx.strokeStyle='#ffffff'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(0,fy); ctx.lineTo(W,fy); ctx.stroke();
    ctx.fillStyle='#e8e8e8'; for(let x=-W; x<W*2; x+=60){ const px=Math.floor(x-off*.45); ctx.fillRect(px,fy-14,4,14); }
    const { top, height } = fieldGeometry(); ctx.fillStyle='#2b7436'; ctx.fillRect(0, top, W, height);
    const stripeW = 120; for(let x=-W; x<W*2; x+=stripeW){ const sx=Math.floor(x-(off*0.35)%stripeW); ctx.fillStyle='rgba(255,255,255,0.04)'; ctx.fillRect(sx, top, stripeW/2, height); }
    const fx = finishLineX(); const finishTopY = fy + FINISH_GAP_FROM_FENCE;
    for (let i=0;i<12;i++){ ctx.fillStyle = i%2 ? '#fff' : '#cc2a2a'; ctx.fillRect(fx-3, finishTopY + i*6, 6,6); }
    for (let i=0;i<10;i++){ ctx.fillStyle = i%2 ? '#fff' : '#111'; ctx.fillRect(fx-28 + i*5, finishTopY - 16, 5,20); }
  }
  function drawHorses(){
    const { top } = fieldGeometry();
    const maxPos = Math.max(...state.players.map(p=>p.pos));
    const leaders = new Set(state.players.map((p,i)=> p.pos===maxPos ? i : null).filter(x=>x!==null));
    ctx.textAlign='center'; ctx.textBaseline='middle';
    state.players.forEach((p,i)=>{
      const cy = p.y ?? (top + 60 + i*40);
      const x  = p.animX ?? startLineX();

      // name plate behind horse ‚Äî gap=35
      const label = p.name; ctx.font='13px system-ui, sans-serif';
      const textW = Math.ceil(ctx.measureText(label).width);
      const padX=7, plateH=18, gap=35;
      const horseHalf = EMOJI_SIZE*0.6/2;
      const rightEdge = x - horseHalf - gap;
      const plateW = textW + padX*2;
      const plateX = Math.max(6, rightEdge - plateW);
      const plateY = cy - plateH/2 + 2;
      ctx.fillStyle='rgba(11,22,43,.85)'; ctx.strokeStyle='#22315c'; ctx.lineWidth=1.5;
      ctx.fillRect(plateX, plateY, plateW, plateH); ctx.strokeRect(plateX, plateY, plateW, plateH);
      ctx.beginPath(); ctx.moveTo(rightEdge, cy); ctx.lineTo(rightEdge-6, cy-5); ctx.lineTo(rightEdge-6, cy+5); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#cfe0ff'; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText(label, plateX+padX, cy);

      if (leaders.has(i)){ ctx.save(); ctx.shadowColor='rgba(255,211,106,.7)'; ctx.shadowBlur=14; ctx.fillStyle='rgba(255,211,106,.18)'; ctx.beginPath(); ctx.arc(x,cy,24,0,Math.PI*2); ctx.fill(); ctx.restore(); }
      if (surged.has(i)){ ctx.save(); ctx.strokeStyle='#6ac2ff'; ctx.globalAlpha=.9; ctx.beginPath(); ctx.arc(x,cy,22,0,Math.PI*2); ctx.stroke(); ctx.restore(); }

      const bob=Math.sin((t*6)+(i*.7))*2.4, tilt=Math.sin((t*1.8)+(i*.9))*0.05;
      ctx.save(); ctx.translate(x, cy + bob); ctx.scale(-1,1); ctx.rotate(tilt);
      ctx.font = `${EMOJI_SIZE}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",system-ui,sans-serif`;
      ctx.fillText(HORSE_EMOJI, 0, 0); ctx.restore();
    });
  }
  function loop(now){
    const dt = Math.max(0.001, Math.min(0.05,(now-lastFrame)/1000));
    lastFrame = now; t += dt;
    const scrollPx = (baseScroll + scrollBoost) * dt; trackOffset = (trackOffset + scrollPx) % 2000; scrollBoost = Math.max(0, scrollBoost - 380*dt);
    const startX=startLineX(), finishX=finishLineX(); const finishIdx = Math.max(1, state.totalRounds - 1);
    state.players.forEach((p,i)=>{ const percent = clamp(p.pos/finishIdx,0,1); const target = startX + percent*(finishX-startX); const speed = surged.has(i)? 520 : 320; p.animX = approach(p.animX, target, dt, speed); });
    resolveCrowding();
    ctx.clearRect(0,0,W,H); drawBackground(trackOffset); drawHorses();
    if (confettiRunning) drawConfetti();
    requestAnimationFrame(loop);
  }

  /* =================== FINISH, PODIUM, CONFETTI =================== */
  function computeFinishOrderFromHistory(){
    const n = state.players.length; const pos = Array(n).fill(0), seen=new Set(), order=[];
    for (const deltas of state.history){
      for (const {idx, delta} of deltas){
        pos[idx] += delta;
        if (pos[idx] >= state.totalRounds && !seen.has(idx)){ seen.add(idx); order.push(idx); if (order.length>=3) return order; }
      }
    }
    return order;
  }
  function maybeShowPodium(){
    if (state.podiumShown) return;
    if (state.finishOrderIdxs.length >= 3){
      const [i1,i2,i3] = state.finishOrderIdxs;
      podium1.textContent = state.players[i1].name; podium2.textContent = state.players[i2].name; podium3.textContent = state.players[i3].name;
      overlay.classList.add('show'); overlay.setAttribute('aria-hidden','false'); state.podiumShown = true;
    }
  }
  function hidePodium(){ overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); }
  function runConfetti(){
    confettiParts = []; const count = 220;
    for(let i=0;i<count;i++){ confettiParts.push({ x: Math.random()*confetti.width,y: -20 - Math.random()*confetti.height*0.4,vx: (Math.random()-0.5)*120,vy: 70 + Math.random()*140,size: 4 + Math.random()*6,rot: Math.random()*Math.PI*2,vr: (Math.random()-0.5)*6,shape: Math.random()<0.5?'rect':'circ',alpha: 0.8+Math.random()*0.2 }); }
    confetti.classList.add('show'); confettiRunning = true; confettiStart = performance.now(); state.confettiStarted = true;
  }
  function stopConfetti(){ confettiRunning=false; confetti.classList.remove('show'); }
  function drawConfetti(){
    const now = performance.now(); const elapsed = (now - confettiStart)/1000; if (elapsed > 8){ stopConfetti(); return; }
    cctx.clearRect(0,0,confetti.width, confetti.height);
    confettiParts.forEach(p=>{
      p.x += p.vx/60; p.y += p.vy/60; p.rot += p.vr/60;
      if (p.x < -20) p.x = confetti.width+20; if (p.x > confetti.width+20) p.x = -20; if (p.y > confetti.height+30) p.y = -20;
      cctx.save(); cctx.globalAlpha = p.alpha; cctx.translate(p.x, p.y); cctx.rotate(p.rot);
      const hue = (p.x/confetti.width*360 + elapsed*60) % 360; cctx.fillStyle = `hsl(${hue}, 90%, 60%)`;
      if (p.shape==='rect'){ cctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6); } else { cctx.beginPath(); cctx.arc(0,0,p.size/2,0,Math.PI*2); cctx.fill(); }
      cctx.restore();
    });
  }
  function csvEscape(s){ return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s; }
  function downloadBlob(content, name, type){ const blob=new Blob([content], {type}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.click(); URL.revokeObjectURL(url); }

  /* =================== ROUND OPS (MANUAL) =================== */
  function getRoundSelections(){
    const correct=[]; let fastest=null;
    for(let i=0;i<NUM_PLAYERS;i++){
      if (document.getElementById(`c${i}`).checked) correct.push(i);
      if (document.getElementById(`f${i}`).checked) fastest=i;
    }
    return {correct, fastest};
  }
  function clearRoundSelections(){
    for(let i=0;i<NUM_PLAYERS;i++){
      const c = document.getElementById(`c${i}`), f=document.getElementById(`f${i}`);
      c.checked=false; f.checked=false; f.dataset.toggled='0';
    }
  }
  function applyDeltas(deltas){
    if (!Array.isArray(deltas) || deltas.length===0) return;
    state.history.push(deltas);
    deltas.forEach(({idx,delta})=> state.players[idx].pos += delta);

    if (state.roundNow < state.totalRounds) state.roundNow++;
    elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`;
    updateSidebar(); updateUndo();

    scrollBoost = 240;
    surged.clear(); deltas.forEach(d=>surged.add(d.idx)); setTimeout(()=>{ surged.clear(); }, 650);

    state.finishOrderIdxs = computeFinishOrderFromHistory();
    if (state.finishOrderIdxs.length >= 1 && !state.confettiStarted) runConfetti();
    maybeShowPodium();
  }
  function applyRound(){ // manual path uses applyDeltas
    const {correct, fastest} = getRoundSelections();
    if (fastest!==null && !correct.includes(fastest)){ elWarn.style.display='block'; return; }
    elWarn.style.display='none';
    const deltas=[]; correct.forEach(i=>deltas.push({idx:i, delta:+1})); if (fastest!==null) deltas.push({idx:fastest, delta:+1});
    clearRoundSelections();
    applyDeltas(deltas);
  }
  function undoRound(){
    const last = state.history.pop(); if(!last) return;
    state.players.forEach(p=> p.pos=0);
    for (const deltas of state.history){ for (const {idx,delta} of deltas) state.players[idx].pos += delta; }
    if (state.roundNow>1) state.roundNow--;
    elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`;
    updateSidebar(); updateUndo();
    state.finishOrderIdxs = computeFinishOrderFromHistory();
    if (state.finishOrderIdxs.length < 1){ stopConfetti(); state.confettiStarted = false; }
    if (state.finishOrderIdxs.length < 3){ hidePodium(); state.podiumShown = false; }
  }
  function resetRace(){
    if(!confirm('Reset the race?')) return;
    state.history=[]; state.roundNow=1;
    state.finishOrderIdxs=[]; state.podiumShown=false; state.confettiStarted=false;
   state.players.forEach(p => {
  p.pos = 0;
  p.animX = startLineX();  // use = here
  p.y = p.baseY;
});
    hidePodium(); stopConfetti();
    elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`;
    clearRoundSelections(); updateSidebar(); updateUndo();
  }
  function exportCsv(){
    const headers = ['Round'].concat(state.players.map(p=>csvEscape(p.name))).join(',');
    const rows=[headers]; const running=state.players.map(()=>0);
    state.history.forEach((rd,i)=>{ rd.forEach(({idx,delta})=>running[idx]+=delta);
      rows.push([String(i+1)].concat(running.map(x=>String(x))).join(',')); });
    rows.push(['Final'].concat(state.players.map(p=>String(p.pos))).join(','));
    const csv = rows.join('\n'); downloadBlob(csv, 'horse_race_results.csv', 'text/csv');
  }

  // Manual controls
  elApplyRounds?.addEventListener('click', ()=>{
    state.totalRounds = clamp(parseInt(elTotalRounds.value,10)||30,1,100);
    state.finishOrderIdxs = computeFinishOrderFromHistory();
    if (state.finishOrderIdxs.length>=1 && !state.confettiStarted) runConfetti();
    maybeShowPodium();
    elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`;
  });
  elApplyRound?.addEventListener('click', applyRound);
  elUndo?.addEventListener('click', undoRound);
  elReset?.addEventListener('click', resetRace);
  elExport?.addEventListener('click', exportCsv);
  document.addEventListener('keydown', (e)=>{
    if (e.target.tagName==='INPUT' && e.target.type==='text') return;
    if (e.code==='Space'){ e.preventDefault(); applyRound(); return; }
    if (e.code==='Backspace'){ e.preventDefault(); undoRound(); return; }
    if (e.key?.toLowerCase?.()==='r'){ e.preventDefault(); resetRace(); return; }
  });

  // Top-right timer (host HUD)
  elStartTop?.addEventListener('click', ()=>{ if (timerInt) return; remaining = clamp(parseInt(elSecsTop.value,10)||20,5,300); elSecsTop.value = remaining; tickClock(true); timerInt = setInterval(()=>tickClock(true),1000); });
  elStopTop ?.addEventListener('click', ()=>{ if(timerInt){ clearInterval(timerInt); timerInt=null; } });
  function tickClock(countdown){
    if (countdown){ remaining=Math.max(0,remaining-1); elClockTop.textContent = fmt(remaining); if (remaining===0) { if (timerInt){ clearInterval(timerInt); timerInt=null; } } }
    else { const v=clamp(parseInt(elSecsTop.value,10)||20,5,300); elClockTop.textContent = fmt(v); }
  }

  /* =================== AUTO VOTING (MODEL A) ‚Äî SINGLE PAGE =================== */
  // Firebase init + Anonymous Auth
  let db=null;
  try{ firebase.initializeApp(firebaseConfig); db=firebase.database(); }catch(e){ if(firebase?.apps?.length){ db=firebase.database(); } }
  firebase.auth().signInAnonymously()
    .then(()=> console.log('Signed in as', firebase.auth().currentUser.uid))
    .catch(err=> console.error('Auth failed', err));

  const engine = { mode:'manual', room:null, qid:0, questions:[], phase:'idle', voteOpenAt:0, endsAt:0, timer:null };

  function setMode(mode){
    engine.mode = mode;
    const perRoundBlock = document.querySelector('.perRound');
    if (perRoundBlock) perRoundBlock.style.display = (mode==='auto') ? 'none' : '';
    questionPane.style.display = (mode==='auto') ? 'flex' : 'none';
    autoStatus.textContent = (mode==='auto') ? 'Auto mode' : 'Manual mode';
  }
  modeSelect?.addEventListener('change', ()=> setMode(modeSelect.value));

  // Load questions.json
  async function loadQuestions(){
    const res = await fetch('questions.json', {cache:'no-store'});
    engine.questions = await res.json();
  }

  // Host: open player self-link (same page, role=player)
  openPlayerLink?.addEventListener('click', ()=>{
    const room = roomCodeEl.value.trim() || '2468';
    openPlayerLink.href = `${location.pathname}?role=player&room=${encodeURIComponent(room)}`;
  });

  // Host: create/join room (claim ownership)
  createOrJoinRoom?.addEventListener('click', async ()=>{
    const room = roomCodeEl.value.trim(); if(!room){ alert('Enter room code'); return; }
    engine.room = room; autoStatus.textContent = 'Loading questions‚Ä¶';
    await loadQuestions();
    autoStatus.textContent = `Room ${room} ready (${engine.questions.length} Qs)`;

    if (db){
      // Claim ownership with current auth uid
      const ownerUid = await getUid();
      await db.ref(`/rooms/${room}/owners/${ownerUid}`).set(true);

      await db.ref(`/rooms/${room}/meta`).set({
        qid: 0, phase: 'idle', totalRounds: engine.questions.length, voteOpenAt: null, endsAt: null
      });
      await db.ref(`/rooms/${room}/current`).remove();
      await db.ref(`/rooms/${room}/applied`).remove();
    }
  });

  // Phases
  forceLockBtn?.addEventListener('click', ()=>{ if(engine.mode==='auto' && engine.phase==='vote_open') enterVoteLock(); });
  skipQBtn?.addEventListener('click', ()=>{ if(engine.mode==='auto') nextQuestion(); });

  function startVote(){
    const q = engine.questions[engine.qid]; if(!q) return;
    engine.phase='vote_open';
    engine.voteOpenAt = Date.now();
    engine.endsAt = engine.voteOpenAt + (q.timeLimitSec||20)*1000;

    qIndex.textContent = 'Q ' + (engine.qid+1);
    qStem.textContent = q.stem || '‚Äî';
    (q.choices||[]).forEach((txt,i)=>{ if(optEls[i]) optEls[i].textContent = ['A','B','C','D'][i] + '. ' + (txt||''); });
    autoStatus.textContent = `Voting‚Ä¶ (${q.timeLimitSec||20}s)`;

    tickVoteClock(); if(engine.timer) clearInterval(engine.timer);
    engine.timer = setInterval(tickVoteClock, 250);

    if (db && engine.room){
      db.ref(`/rooms/${engine.room}/meta`).update({ qid: engine.qid, phase:'vote_open', voteOpenAt: engine.voteOpenAt, endsAt: engine.endsAt });
      db.ref(`/rooms/${engine.room}/current`).set({ qid: engine.qid, stem: q.stem, choices: q.choices, timeLeft: Math.ceil((engine.endsAt - Date.now())/1000) });
      db.ref(`/rooms/${engine.room}/answers/${engine.qid}`).remove();
    }
  }
  function tickVoteClock(){
    const left = Math.max(0, Math.ceil((engine.endsAt - Date.now())/1000));
    voteClock.textContent = left+'s';
    if (db && engine.room) db.ref(`/rooms/${engine.room}/current/timeLeft`).set(left);
    if (left<=0){ clearInterval(engine.timer); engine.timer=null; enterVoteLock(); }
  }

  async function enterVoteLock(){
    engine.phase='vote_lock'; autoStatus.textContent='Locking & scoring‚Ä¶';
    if (db && engine.room){ await db.ref(`/rooms/${engine.room}/meta/phase`).set('vote_lock'); }

    // Get votes
    let votes = {};
    if (db && engine.room){
      const snap = await db.ref(`/rooms/${engine.room}/answers/${engine.qid}`).get();
      votes = snap.val() || {};
    }
    const q = engine.questions[engine.qid]; const correctIndex = q.correctIndex;

    // Map uid -> name -> seat index
    let uidName = {}, nameToIdx = new Map(state.players.map((p,i)=>[p.name.trim(), i]));
    if (db && engine.room){
      const ps = (await db.ref(`/rooms/${engine.room}/players`).get()).val() || {};
      for (const [u,info] of Object.entries(ps)){ uidName[u] = String(info?.name||'').trim(); }
    }

    // Correct voters list
    const correctUIDs = Object.keys(votes).filter(u=> votes[u]?.choice===correctIndex && votes[u]?.serverTs < engine.endsAt);

    // Build deltas: +1 for correct
    const deltas=[];
    const correctIdxs=[];
    correctUIDs.forEach(u=>{ const idx = nameToIdx.get(uidName[u]||''); if (idx!=null){ correctIdxs.push(idx); deltas.push({idx, delta:1}); } });

    // Fastest-correct +1
    if (correctUIDs.length){
      const ranked = correctUIDs.map(u=>({u, ts: votes[u].serverTs})).sort((a,b)=>a.ts-b.ts);
      const K = Math.max(1, Math.min(5, Math.round(0.15 * ranked.length)));
      const cutoffTs = ranked[Math.min(K-1, ranked.length-1)].ts;
      const fastestSet = new Set(ranked.filter(r=> r.ts <= cutoffTs).map(r=>r.u));
      ranked.forEach(({u})=>{
        if (fastestSet.has(u)){
          const idx = nameToIdx.get(uidName[u]||'');
          if (idx!=null){
            const d = deltas.find(x=>x.idx===idx);
            if (d) d.delta = Math.min(2, d.delta+1);
          }
        }
      });
    }

    // Reveal then apply
    engine.phase='reveal'; autoStatus.textContent = `Reveal ‚Äî correct: ${['A','B','C','D'][correctIndex]}`;
    if (db && engine.room){ await db.ref(`/rooms/${engine.room}/meta/phase`).set('reveal'); }

    setTimeout(async ()=>{
      engine.phase='result';
      if (db && engine.room){ await db.ref(`/rooms/${engine.room}/meta/phase`).set('result'); }

      // Idempotence guard
      let already=false;
      if (db && engine.room){
        const path = `/rooms/${engine.room}/applied/${engine.qid}`;
        const snap = await db.ref(path).get(); already = !!snap.val();
        if (!already){ applyDeltas(deltas); await db.ref(path).set(true); }
      } else {
        applyDeltas(deltas);
      }
      nextQuestion();
    }, 1200);
  }
  function nextQuestion(){
    engine.qid++;
    if (engine.qid >= engine.questions.length){
      autoStatus.textContent = 'Done ‚Äî no more questions.';
      if (db && engine.room){ db.ref(`/rooms/${engine.room}/meta/phase`).set('idle'); }
      return;
    }
    if (db && engine.room){ db.ref(`/rooms/${engine.room}/meta/qid`).set(engine.qid); }
    startVote();
  }

  /* =================== PLAYER VIEW (same page, ?role=player) =================== */
  let role = new URL(location.href).searchParams.get('role') || 'host';
  if (role === 'player'){
    // Hide host UI, show player view
    document.querySelector('.raceTop')?.style.setProperty('display','none');
    document.querySelectorAll('.bottom')?.forEach((b,i)=>{ if (i===0) b.style.display='none'; }); // hide first bottom (host controls)
    pv.wrapper.style.display = 'block';

    // Pre-fill room/name from URL
    const qs = new URL(location.href).searchParams;
    if (qs.get('room')) pv.room.value = qs.get('room');
    if (qs.get('name')) pv.name.value = qs.get('name');

    let room=null, pname=null;

    pv.join.addEventListener('click', async ()=>{
      if (!db){ alert('Firebase not configured'); return; }
      room = pv.room.value.trim(); pname = pv.name.value.trim() || 'Player';
      if(!room){ alert('Enter room'); return; }
      pv.status.textContent = 'Joining‚Ä¶';
      const uid = await getUid();
      await db.ref(`/rooms/${room}/players/${uid}`).set({ name: pname, active:true, joinedAt: firebase.database.ServerValue.TIMESTAMP });
      pv.status.textContent = 'Joined as '+pname;
      listenPlayerRoom();
    });

    function listenPlayerRoom(){
      db.ref(`/rooms/${room}/meta`).on('value', snap=>{
        const v = snap.val() || {};
        const show = (v.phase==='vote_open' || v.phase==='vote_lock' || v.phase==='reveal');
        pv.card.style.display = show ? 'block' : 'none';
      });
      db.ref(`/rooms/${room}/current`).on('value', snap=>{
        const v = snap.val() || {};
        if (v.qid==null){ pv.card.style.display='none'; return; }
        pv.qIndex.textContent = 'Q ' + (v.qid+1);
        pv.stem.textContent = v.stem || '‚Äî';
        pv.clock.textContent = v.timeLeft ?? '‚Äî';
        const ch = v.choices || [];
        pv.choices.forEach((btn,i)=> btn.textContent = ['A','B','C','D'][i] + (ch[i] ? ('. '+ch[i]) : ''));
      });
    }
    pv.choices.forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        if(!db){ return; }
        const meta = (await db.ref(`/rooms/${pv.room.value.trim()}/meta`).get()).val() || {};
        if (meta.phase !== 'vote_open'){ pv.submitted.textContent = 'Voting closed'; return; }
        const choice = Number(btn.dataset.i);
        const uid = await getUid();
        await db.ref(`/rooms/${pv.room.value.trim()}/answers/${meta.qid}/${uid}`).set({
          choice, serverTs: firebase.database.ServerValue.TIMESTAMP
        });
        pv.submitted.textContent = 'Submitted ' + ['A','B','C','D'][choice];
      });
    });
  } else {
    // HOST view ‚Äî default
    setMode(modeSelect?.value || 'manual');
  }

  /* =================== BOOT =================== */
  function init(){
    // Read ?p1= etc (seat names)
    const url = new URL(location.href);
    for(let i=1;i<=NUM_PLAYERS;i++){ const v=url.searchParams.get('p'+i); if(v) INIT_NAMES[i-1]=decodeURIComponent(v); }
    state.players = Array.from({length:NUM_PLAYERS},(_,i)=>({name:INIT_NAMES[i], pos:0, animX: startLineX(), y:null, baseY:null}));
    buildNameEditor(); buildRoundInputs();
    elTotalRounds && (elTotalRounds.value = state.totalRounds);
    elRoundHud && (elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`);
    resize(); lastFrame=performance.now(); requestAnimationFrame(loop);
  }
  init();
})();
</script>

</body>
</html>
