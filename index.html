<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Horse Race Quiz ‚Äî Field + Early Confetti + Podium</title>
<style>
  :root{
    --bg:#0c1220; --card:#131a2e; --ink:#e9f0ff; --muted:#9aa4bf; --edge:#22315c;
    --ok:#33d17a; --bad:#ff6b6b; --acc:#6ac2ff; --gold:#ffd36a;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--ink); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}

  /* Race area takes 75% of screen */
  .raceTop{
    height:75vh; min-height:480px; position:relative; border-bottom:1px solid var(--edge)
  }
  canvas#raceCanvas{position:absolute; inset:0; width:100%; height:100%}

  .hud{
    position:absolute; left:12px; top:10px; display:flex; gap:8px; flex-wrap:wrap;
    background:rgba(15,21,39,.5); border:1px solid var(--edge); backdrop-filter:blur(6px);
    padding:6px 8px; border-radius:8px; font-size:11px; z-index:5;
  }
  .hud .pill{padding:2px 6px; border-radius:999px; font-size:11px; background:#0f1527; border:1px solid var(--edge); color:var(--muted)}
  .hud .title{font-weight:800}
  .hudRight{position:absolute; right:12px; top:10px; display:flex; gap:8px; align-items:center; font-size:12px; z-index:5;}
  .clock{font-variant-numeric:tabular-nums; font-weight:800}
  .btnTiny{cursor:pointer; border:1px solid var(--edge); background:#0f1527; color:var(--ink); padding:4px 6px; border-radius:6px; font-weight:600; font-size:11px}

  /* Compact controls */
  .bottom{max-width:1100px; margin:12px auto; padding:0 12px 12px}
  .card{background:var(--card); border:1px solid var(--edge); border-radius:10px; padding:10px}
  .row{display:flex; align-items:center; gap:8px; margin:6px 0}
  label{font-size:13px;color:var(--muted)}
  input[type="text"],input[type="number"]{background:#0f1527; color:var(--ink); border:1px solid var(--edge); border-radius:6px; padding:4px 6px; font-size:13px}
  input[type="text"]{width:120px} input[type="number"]{width:70px}
  .btn{cursor:pointer; border:1px solid var(--edge); background:#0f1527; color:var(--ink); padding:6px 8px; border-radius:8px; font-weight:600; font-size:13px}
  .btn.good{border-color:#245c43; background:#0c1a16}
  .btn.warn{border-color:#5c2424; background:#1a0c0c}
  .btn.accent{border-color:#274f7c; background:#0d1626}
  .btn.gold{border-color:#7c6a27; background:#1a1506; color:var(--gold)}

  .playersGrid{display:grid; grid-template-columns: 1fr auto auto; gap:6px 10px; align-items:center; margin-top:6px}
  .tiny{font-size:11px; color:var(--muted)}
  .warning{color:var(--bad); font-weight:600; display:none; font-size:12px}

  .perRound{margin-top:8px; border-top:1px dashed var(--edge); padding-top:8px}
  .perRound h3{margin:0 0 6px; font-size:14px}
  .perRound .grid{display:grid; grid-template-columns: 1fr 70px 70px; gap:6px 10px; align-items:center}
  .footerBtns{display:flex; gap:6px; margin-top:8px; flex-wrap:wrap}

  /* Podium overlay */
  .overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(9,13,25,.65); backdrop-filter: blur(6px); z-index:20;
  }
  .overlay.show{display:flex}
  .podium{
    position:relative; background:#0f1527; border:1px solid var(--edge);
    border-radius:14px; padding:16px 18px; width:min(680px, 92vw);
    box-shadow:0 10px 40px rgba(0,0,0,.35);
  }
  .podium h2{margin:0 0 8px; font-size:20px}
  .podium .stage{display:flex; gap:10px; align-items:flex-end; justify-content:center; margin-top:10px}
  .plinth{border:1px solid var(--edge); background:#0c1529; border-radius:10px 10px 6px 6px; width:30%; text-align:center; padding:8px 6px}
  .plinth .place{font-size:22px; font-weight:900}
  /* Bigger, black names */
  .plinth .name{margin-top:4px; font-size:20px; font-weight:900; color:#000 !important}
  .p1{height:180px; background:linear-gradient(#ffe8a6,#ffd36a); color:#1a1400}
  .p2{height:150px; background:linear-gradient(#e8edf5,#cfd8e6); color:#0e1218}
  .p3{height:130px; background:linear-gradient(#ffd9b3,#ffb873); color:#241200}
  .podium .actions{display:flex; justify-content:center; gap:10px; margin-top:12px}
  .podium .actions .btn{font-size:13px}

  /* Confetti canvas */
  #confettiCanvas{
    position:fixed; inset:0; pointer-events:none; z-index:19; display:none;
  }
  #confettiCanvas.show{display:block;}
</style>
</head>
<body>

<!-- TOP: animated race -->
<div class="raceTop">
  <canvas id="raceCanvas"></canvas>

  <div class="hud">
    <span class="title">üêé Horse Race</span>
    <span id="roundHud" class="pill">Round 1/30</span>
    <span class="pill">Correct = +1</span>
    <span class="pill">Fastest correct = +1</span>
  </div>
  <div class="hudRight">
    <label class="tiny">Round timer (s)</label>
    <input id="secsTop" type="number" min="5" max="300" value="20" />
    <button class="btnTiny" id="startTimerTop">Start (T)</button>
    <button class="btnTiny" id="stopTimerTop">Stop</button>
    <div class="clock" id="clockTop">00:20</div>
  </div>
</div>

<!-- BOTTOM: controls/scoring -->
<div class="bottom">
  <div class="card">
    <div class="row">
      <label>Total rounds</label>
      <input id="totalRounds" type="number" min="1" max="100" value="30">
      <button class="btn accent" id="applyRounds">Apply</button>
      <span class="tiny">Keys: <strong>1‚Äì7</strong> fastest (+correct), <strong>Shift+1‚Äì7</strong> toggle correct, <strong>Space</strong> Apply, <strong>Backspace</strong> Undo, <strong>R</strong> Reset, <strong>T</strong> Timer.</span>
    </div>

    <div class="row"><label>Player names</label></div>
    <div class="playersGrid" id="nameGrid"></div>

    <div class="perRound">
      <h3>Round Input</h3>
      <div class="tiny">Tick everyone who was <strong>correct</strong>. Select <strong>fastest</strong> among them. Then Apply.</div>
      <div class="grid" id="roundGrid"></div>
      <div class="warning" id="warn">Fastest must be one of the correct players (or leave fastest blank).</div>
      <div class="footerBtns">
        <button class="btn good" id="applyRound">Apply Round (Space)</button>
        <button class="btn" id="undoRound" disabled>Undo (Backspace)</button>
        <button class="btn warn" id="resetRace">Reset Race (R)</button>
        <button class="btn gold" id="exportCsv">Export CSV</button>
      </div>
    </div>
  </div>
</div>

<!-- Podium + confetti -->
<canvas id="confettiCanvas"></canvas>
<div id="podiumOverlay" class="overlay" aria-hidden="true">
  <div class="podium" role="dialog" aria-modal="true" aria-labelledby="podiumTitle">
    <h2 id="podiumTitle">üèÜ Top 3 Finishers</h2>
    <div class="stage">
      <div class="plinth p2">
        <div class="place">ü•à 2nd</div>
        <div class="name" id="podium2">‚Äî</div>
      </div>
      <div class="plinth p1">
        <div class="place">ü•á 1st</div>
        <div class="name" id="podium1">‚Äî</div>
      </div>
      <div class="plinth p3">
        <div class="place">ü•â 3rd</div>
        <div class="name" id="podium3">‚Äî</div>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="closePodium">Close</button>
      <button class="btn gold" id="copyWinners">Copy winners</button>
    </div>
  </div>
</div>

<script>
(function(){
  // ----- Config -----
  const NUM_PLAYERS = 7;
  const INIT_NAMES  = ["Player 1","Player 2","Player 3","Player 4","Player 5","Player 6","Player 7"];

  // Field look
  const FIELD_TOP = 150;
  const FIELD_BOTTOM_MARGIN = 40;

  // Horses (emoji, mirrored to face right)
  const HORSE_EMOJI = 'üêé';
  const EMOJI_SIZE  = 44;

  // Crowd avoidance tuning
  const X_NEAR = 110, Y_SEP = 28, SPRING = 0.04, ITERATIONS = 2;

  // ----- State -----
  const state = {
    totalRounds: 30,
    roundNow: 1,
    players: [],            // {name, pos, animX, y, baseY}
    history: [],            // per-round deltas [{idx,delta}, ...]
    finishOrderIdxs: [],    // indices in order of finishing
    podiumShown: false,
    confettiStarted: false
  };

  // ----- DOM -----
  const elTotalRounds = document.getElementById('totalRounds');
  const elApplyRounds = document.getElementById('applyRounds');
  const elNameGrid = document.getElementById('nameGrid');
  const elRoundGrid = document.getElementById('roundGrid');
  const elWarn = document.getElementById('warn');
  const elApplyRound = document.getElementById('applyRound');
  const elUndo = document.getElementById('undoRound');
  const elReset = document.getElementById('resetRace');
  const elExport = document.getElementById('exportCsv');
  const elRoundHud = document.getElementById('roundHud');

  // Timer HUD
  const elSecsTop = document.getElementById('secsTop');
  const elStartTop = document.getElementById('startTimerTop');
  const elStopTop  = document.getElementById('stopTimerTop');
  const elClockTop = document.getElementById('clockTop');
  let timerInt = null, remaining = 0;

  // Podium + confetti
  const overlay = document.getElementById('podiumOverlay');
  const podium1 = document.getElementById('podium1');
  const podium2 = document.getElementById('podium2');
  const podium3 = document.getElementById('podium3');
  document.getElementById('closePodium').onclick = ()=>hidePodium();
  document.getElementById('copyWinners').onclick = ()=>{
    navigator.clipboard?.writeText(`1st: ${podium1.textContent}, 2nd: ${podium2.textContent}, 3rd: ${podium3.textContent}`);
  };

  // ----- Canvas -----
  const canvas = document.getElementById('raceCanvas');
  const ctx = canvas.getContext('2d');
  let W=0, H=0, t=0, lastFrame=0;
  let baseScroll=140, scrollBoost=0, trackOffset=0;
  const leftPad=110, rightPad=8;
  const finishLineX = ()=> W - rightPad;
  const startLineX  = ()=> leftPad;

  // Surge ring fx
  const surged = new Set();

  // Confetti layer
  const confetti = document.getElementById('confettiCanvas');
  const cctx = confetti.getContext('2d');
  let confettiRunning=false, confettiStart=0, confettiParts=[];

  // ----- Build UI -----
  function buildNameEditor(){
    elNameGrid.innerHTML = '';
    state.players.forEach((p,i)=>{
      const nameInput = document.createElement('input');
      nameInput.type='text'; nameInput.value=p.name;
      nameInput.addEventListener('input', e=> p.name = e.target.value || `Player ${i+1}`);
      const posPill = document.createElement('div'); posPill.className='tiny'; posPill.id=`posPill${i}`; posPill.textContent='Moves: 0';
      const seat = document.createElement('div'); seat.className='tiny'; seat.textContent = `Seat #${i+1}`;
      elNameGrid.append(nameInput,posPill,seat);
    });
  }
  function buildRoundInputs(){
    elRoundGrid.innerHTML='';
    const h1=mk('div','tiny','Player'), h2=mk('div','tiny','Correct'), h3=mk('div','tiny','Fastest');
    elRoundGrid.append(h1,h2,h3);
    state.players.forEach((p,i)=>{
      const nameCell=mk('div',null), correctCell=mk('div',null), fastestCell=mk('div',null);
      const c=mk('input'); c.type='checkbox'; c.id=`c${i}`;
      const f=mk('input'); f.type='radio'; f.name='fastest'; f.id=`f${i}`;
      const lab=mk('label',null,p.name); lab.htmlFor=`c${i}`; lab.id=`labC${i}`;
      nameCell.appendChild(lab); correctCell.appendChild(c); fastestCell.appendChild(f);
      elRoundGrid.append(nameCell,correctCell,fastestCell);
    });
    // allow radio to toggle off on second click
    elRoundGrid.addEventListener('click', (e)=>{
      if(e.target && e.target.type==='radio'){
        e.target.dataset.toggled = e.target.dataset.toggled==='1' ? '0' : '1';
        if (e.target.dataset.toggled==='0') e.target.checked=false;
        [...document.querySelectorAll('input[name="fastest"]')].forEach(r=>{ if(r!==e.target) r.dataset.toggled='0'; });
      }
    });
  }

  // ----- Controls -----
  elApplyRounds.addEventListener('click', ()=>{
    state.totalRounds = clamp(parseInt(elTotalRounds.value,10)||30,1,100);
    // Re-evaluate finish states
    state.finishOrderIdxs = computeFinishOrderFromHistory();
    if (state.finishOrderIdxs.length>=1 && !state.confettiStarted) runConfetti();
    maybeShowPodium();
    elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`;
  });
  elApplyRound.addEventListener('click', applyRound);
  elUndo.addEventListener('click', undoRound);
  elReset.addEventListener('click', resetRace);
  elExport.addEventListener('click', exportCsv);

  // Keyboard
  document.addEventListener('keydown', (e)=>{
    if (e.target.tagName==='INPUT' && e.target.type==='text') return;
    if (e.code==='Space'){ e.preventDefault(); applyRound(); return; }
    if (e.code==='Backspace'){ e.preventDefault(); undoRound(); return; }
    if (e.key.toLowerCase()==='r'){ e.preventDefault(); resetRace(); return; }
    if (e.key.toLowerCase()==='t'){ e.preventDefault(); if(timerInt) stopTimer(); else startTimer(); return; }
    const map = { Digit1:0,Digit2:1,Digit3:2,Digit4:3,Digit5:4,Digit6:5,Digit7:6,
                  Numpad1:0,Numpad2:1,Numpad3:2,Numpad4:3,Numpad5:4,Numpad6:5,Numpad7:6 };
    const idx = map[e.code] ?? null;
    if (idx!==null){
      e.preventDefault();
      if (e.shiftKey){
        const c = document.getElementById(`c${idx}`); c.checked=!c.checked;
      } else {
        const f = document.getElementById(`f${idx}`);
        [...document.querySelectorAll('input[name="fastest"]')].forEach(r=>{ r.checked=false; r.dataset.toggled='0'; });
        f.checked=true; f.dataset.toggled='1';
        const c = document.getElementById(`c${idx}`); c.checked=true;
      }
    }
  });

  // Timer
  elStartTop.addEventListener('click', startTimer);
  elStopTop.addEventListener('click', stopTimer);
  function startTimer(){
    if (timerInt) return;
    remaining = clamp(parseInt(elSecsTop.value,10)||20,5,300);
    elSecsTop.value = remaining; tickClock(true);
    timerInt = setInterval(()=>tickClock(true),1000);
  }
  function stopTimer(){ if(timerInt){ clearInterval(timerInt); timerInt=null; } }
  function tickClock(countdown){
    if (countdown){
      remaining = Math.max(0, remaining-1);
      elClockTop.textContent = fmt(remaining);
      if (remaining===0) stopTimer();
    } else {
      const v = clamp(parseInt(elSecsTop.value,10)||20,5,300);
      elClockTop.textContent = fmt(v);
    }
  }
  const fmt = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;

  // ----- Round ops -----
  function getRoundSelections(){
    const correct=[]; let fastest=null;
    for(let i=0;i<NUM_PLAYERS;i++){
      if (document.getElementById(`c${i}`).checked) correct.push(i);
      if (document.getElementById(`f${i}`).checked) fastest=i;
    }
    return {correct, fastest};
  }
  function clearRoundSelections(){
    for(let i=0;i<NUM_PLAYERS;i++){
      const c = document.getElementById(`c${i}`), f=document.getElementById(`f${i}`);
      c.checked=false; f.checked=false; f.dataset.toggled='0';
    }
  }
  function applyRound(){
    const {correct, fastest} = getRoundSelections();
    if (fastest!==null && !correct.includes(fastest)){ elWarn.style.display='block'; return; }
    elWarn.style.display='none';

    const deltas=[];
    correct.forEach(i=>deltas.push({idx:i, delta:+1}));
    if (fastest!==null) deltas.push({idx:fastest, delta:+1});

    state.history.push(deltas);
    // Apply deltas to positions
    deltas.forEach(({idx,delta})=> state.players[idx].pos += delta);

    // Progress round counter
    if (state.roundNow < state.totalRounds) state.roundNow++;
    elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`;

    clearRoundSelections(); updateSidebar(); updateUndo();

    // FX
    scrollBoost = 240;
    surged.clear(); deltas.forEach(d=>surged.add(d.idx)); setTimeout(()=>{ surged.clear(); }, 650);

    // Recompute finish order and trigger effects
    state.finishOrderIdxs = computeFinishOrderFromHistory();
    if (state.finishOrderIdxs.length >= 1 && !state.confettiStarted) runConfetti(); // EARLY confetti on 1st finisher
    maybeShowPodium(); // show podium when 3rd finishes
  }
  function undoRound(){
    const last = state.history.pop();
    if (!last) return;

    // Recompute ALL positions from scratch to keep consistency
    recalcPositionsFromHistory();

    // Step back round
    if (state.roundNow > 1) state.roundNow--;
    elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`;

    updateSidebar(); updateUndo();

    // Re-evaluate finish milestones after undo
    state.finishOrderIdxs = computeFinishOrderFromHistory();

    // Confetti: if no one has finished anymore, stop & reset flag
    if (state.finishOrderIdxs.length < 1){
      stopConfetti();
      state.confettiStarted = false;
    }
    // Podium: hide if fewer than 3 finishers
    if (state.finishOrderIdxs.length < 3){
      hidePodium();
      state.podiumShown = false;
    }
  }
  function resetRace(){
    if(!confirm('Reset the race?')) return;
    state.history = [];
    state.roundNow = 1;
    state.finishOrderIdxs = [];
    state.podiumShown = false;
    state.confettiStarted = false;
    state.players.forEach(p=>{ p.pos=0; p.animX=startLineX(); p.y=p.baseY; });
    hidePodium(); stopConfetti();
    elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`;
    clearRoundSelections(); updateSidebar(); updateUndo();
  }
  function recalcPositionsFromHistory(){
    state.players.forEach(p=> p.pos = 0);
    for (const deltas of state.history){
      for (const {idx,delta} of deltas) state.players[idx].pos += delta;
    }
  }
  function exportCsv(){
    const headers = ['Round'].concat(state.players.map(p=>csvEscape(p.name))).join(',');
    const rows=[headers]; const running=state.players.map(()=>0);
    state.history.forEach((rd,i)=>{ rd.forEach(({idx,delta})=>running[idx]+=delta);
      rows.push([String(i+1)].concat(running.map(x=>String(x))).join(',')); });
    rows.push(['Final'].concat(state.players.map(p=>String(p.pos))).join(','));
    const csv = rows.join('\n'); downloadBlob(csv, 'horse_race_results.csv', 'text/csv');
  }
  function updateSidebar(){ state.players.forEach((p,i)=>{ const el=document.getElementById(`posPill${i}`); if(el) el.textContent=`Moves: ${p.pos}`; }); }
  function updateUndo(){ elUndo.disabled = state.history.length===0; }

  // ----- Geometry & drawing -----
  function approach(cur,tgt,dt,speed){ const d=tgt-cur; const step=Math.sign(d)*Math.min(Math.abs(d), speed*dt); return cur+step; }

  function resize(){
    const r = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(r.width  * devicePixelRatio);
    canvas.height = Math.floor(r.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    W=r.width; H=r.height;

    // Confetti canvas (not high-DPI; looks fine 1x)
    confetti.width = Math.floor(r.width);
    confetti.height= Math.floor(r.height);

    layoutFieldY();
  }
  window.addEventListener('resize', resize);

  function fieldGeometry(){
    const top = FIELD_TOP;
    const bot = H - FIELD_BOTTOM_MARGIN;
    const height = Math.max(60, bot - top);
    return { top, bot, height };
  }
  function layoutFieldY(){
    const { top, height } = fieldGeometry();
    for(let i=0;i<state.players.length;i++){
      const base = top + ((i + 0.5) / NUM_PLAYERS) * height;
      const spread = height / NUM_PLAYERS * 0.35;
      const jitter = (Math.random()*2 - 1) * spread;
      const baseY = clamp(base + jitter, top + 24, top + height - 24);
      const p = state.players[i];
      p.baseY = baseY;
      if (p.y == null) p.y = baseY;
    }
  }
  function resolveCrowding(){
    const { top, bot } = fieldGeometry();
    const minY = top + 24, maxY = bot - 24;

    // spring back to base
    state.players.forEach(p=>{ p.y += (p.baseY - p.y) * SPRING; });

    // repel if close
    for(let it=0; it<ITERATIONS; it++){
      for(let i=0;i<state.players.length;i++){
        for(let j=i+1;j<state.players.length;j++){
          const a = state.players[i], b = state.players[j];
          const dx = Math.abs(a.animX - b.animX);
          if (dx > X_NEAR) continue;
          const dy = b.y - a.y, ady = Math.abs(dy);
          if (ady < Y_SEP){
            const overlap = (Y_SEP - ady) * (1 - dx / X_NEAR);
            const dir = dy >= 0 ? 1 : -1;
            a.y -= overlap * 0.5 * dir;
            b.y += overlap * 0.5 * dir;
          }
        }
      }
      state.players.forEach(p=>{ p.y = clamp(p.y, minY, maxY); });
    }
  }

  function drawBackground(off){
    // sky
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#0f1836'); g.addColorStop(1,'#0b1329');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    // stands
    const y=60; ctx.save(); ctx.globalAlpha=.35; ctx.fillStyle='#0b1e35';
    for(let x=-W; x<W*2; x+=160){ ctx.fillRect(Math.floor(x-off*.18), y, 120, 30); }
    ctx.restore();

    // fence
    const fy=120; ctx.strokeStyle='#ffffff'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(0,fy); ctx.lineTo(W,fy); ctx.stroke();
    ctx.fillStyle='#e8e8e8';
    for(let x=-W; x<W*2; x+=60){ const px=Math.floor(x-off*.45); ctx.fillRect(px,fy-14,4,14); }

    // big green field
    const { top, height } = fieldGeometry();
    ctx.fillStyle = '#2b7436';
    ctx.fillRect(0, top, W, height);

    // subtle mow stripes
    const stripeW = 120;
    for(let x=-W; x<W*2; x+=stripeW){
      const sx = Math.floor(x - (off*0.35)%stripeW);
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fillRect(sx, top, stripeW/2, height);
    }

    // finish marker

const fx = finishLineX();
for(let i=0;i<12;i++){
  ctx.fillStyle = i%2 ? '#fff' : '#cc2a2a';
  ctx.fillRect(fx-3, top-18 + i*6, 6,6);
}
for(let i=0;i<10;i++){
  ctx.fillStyle = i%2 ? '#fff' : '#111';
  ctx.fillRect(fx-28 + i*5, top-28, 5,20);
}
// keep the label slightly in from the edge so it‚Äôs visible
ctx.fillStyle = '#f0f6ff';
ctx.font = '12px system-ui, sans-serif';
ctx.textAlign = 'right';
ctx.fillText('FINISH', Math.min(W-6, fx - 6), top-32);
ctx.textAlign = 'start';

  function drawHorses(){
    const { top } = fieldGeometry();
    const maxPos = Math.max(...state.players.map(p=>p.pos));
    const leaders = new Set(state.players.map((p,i)=> p.pos===maxPos ? i : null).filter(x=>x!==null));

    ctx.textAlign='center'; ctx.textBaseline='middle';

    state.players.forEach((p,i)=>{
      const cy = p.y ?? (top + 60 + i*40);
      const x  = p.animX ?? startLineX();

      // trailing name plate
      const label = p.name;
      ctx.font='13px system-ui, sans-serif';
      const textW = Math.ceil(ctx.measureText(label).width);
      const padX=7, plateH=18, gap=10;
      const horseHalf = EMOJI_SIZE*0.6/2;
      const rightEdge = x - horseHalf - gap;
      const plateW = textW + padX*2;
      const plateX = Math.max(6, rightEdge - plateW);
      const plateY = cy - plateH/2 + 2;
      ctx.fillStyle='rgba(11,22,43,.85)'; ctx.strokeStyle='#22315c'; ctx.lineWidth=1.5;
      ctx.fillRect(plateX, plateY, plateW, plateH); ctx.strokeRect(plateX, plateY, plateW, plateH);
      ctx.beginPath(); ctx.moveTo(rightEdge, cy); ctx.lineTo(rightEdge-6, cy-5); ctx.lineTo(rightEdge-6, cy+5); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#cfe0ff'; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText(label, plateX+padX, cy);

      // leader glow
      if (leaders.has(i)){
        ctx.save(); ctx.shadowColor='rgba(255,211,106,.7)'; ctx.shadowBlur=14;
        ctx.fillStyle='rgba(255,211,106,.18)'; ctx.beginPath(); ctx.arc(x,cy,24,0,Math.PI*2); ctx.fill(); ctx.restore();
      }
      // surge ring
      if (surged.has(i)){
        ctx.save(); ctx.strokeStyle='#6ac2ff'; ctx.globalAlpha=.9; ctx.beginPath(); ctx.arc(x,cy,22,0,Math.PI*2); ctx.stroke(); ctx.restore();
      }

      // bob/tilt + emoji horse (mirrored to face right)
      const bob = Math.sin((t*6)+(i*.7))*2.4;
      const tilt= Math.sin((t*1.8)+(i*.9))*0.05;

      ctx.save();
      ctx.translate(x, cy + bob);
      ctx.scale(-1, 1);       // flip horizontally to face right
      ctx.rotate(tilt);
      ctx.font = `${EMOJI_SIZE}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",system-ui,sans-serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(HORSE_EMOJI, 0, 0);
      ctx.restore();
    });
  }

  function loop(now){
    const dt = Math.max(0.001, Math.min(0.05,(now-lastFrame)/1000));
    lastFrame = now; t += dt;

    // scrolling bg
    const scrollPx = (baseScroll + scrollBoost) * dt;
    trackOffset = (trackOffset + scrollPx) % 2000;
    scrollBoost = Math.max(0, scrollBoost - 380*dt);

    // logical X target by score
    const startX=startLineX(), finishX=finishLineX();
    const finishIdx = Math.max(1, state.totalRounds - 1);
    state.players.forEach((p,i)=>{
      const percent = clamp(p.pos/finishIdx,0,1);
      const target = startX + percent*(finishX-startX);
      const speed = surged.has(i)? 520 : 320;
      p.animX = approach(p.animX, target, dt, speed);
    });

    // y crowding
    resolveCrowding();

    // draw scene
    ctx.clearRect(0,0,W,H);
    drawBackground(trackOffset);
    drawHorses();

    // confetti layer
    if (confettiRunning) drawConfetti();

    requestAnimationFrame(loop);
  }

  // ----- Podium + Confetti -----
  function computeFinishOrderFromHistory(){
    const n = state.players.length;
    const pos = Array(n).fill(0);
    const seen = new Set();
    const order = [];
    for (const deltas of state.history){
      for (const {idx, delta} of deltas){
        pos[idx] += delta;
        if (pos[idx] >= state.totalRounds && !seen.has(idx)){
          seen.add(idx);
          order.push(idx);
          if (order.length>=3) return order;
        }
      }
    }
    return order;
  }

  function maybeShowPodium(){
    if (state.podiumShown) return;
    if (state.finishOrderIdxs.length >= 3){
      const [i1,i2,i3] = state.finishOrderIdxs;
      podium1.textContent = state.players[i1].name;
      podium2.textContent = state.players[i2].name;
      podium3.textContent = state.players[i3].name;
      overlay.classList.add('show');
      overlay.setAttribute('aria-hidden','false');
      state.podiumShown = true;
    }
  }
  function hidePodium(){
    overlay.classList.remove('show');
    overlay.setAttribute('aria-hidden','true');
  }

  // Simple confetti burst
  function runConfetti(){
    confettiParts = [];
    const count = 220;
    for(let i=0;i<count;i++){
      confettiParts.push({
        x: Math.random()*W,
        y: -20 - Math.random()*H*0.4,
        vx: (Math.random()-0.5)*120,
        vy: 70 + Math.random()*140,
        size: 4 + Math.random()*6,
        rot: Math.random()*Math.PI*2,
        vr: (Math.random()-0.5)*6,
        shape: Math.random()<0.5?'rect':'circ',
        alpha: 0.8+Math.random()*0.2
      });
    }
    confetti.classList.add('show');
    confettiRunning = true;
    confettiStart = performance.now();
    state.confettiStarted = true;
  }
  function stopConfetti(){ confettiRunning=false; confetti.classList.remove('show'); }
  function drawConfetti(){
    const now = performance.now();
    const elapsed = (now - confettiStart)/1000;
    if (elapsed > 8){ stopConfetti(); return; }
    cctx.clearRect(0,0,confetti.width, confetti.height);
    confettiParts.forEach(p=>{
      p.x += p.vx/60; p.y += p.vy/60; p.rot += p.vr/60;
      if (p.x < -20) p.x = confetti.width+20;
      if (p.x > confetti.width+20) p.x = -20;
      if (p.y > confetti.height+30) p.y = -20;

      cctx.save();
      cctx.globalAlpha = p.alpha;
      cctx.translate(p.x, p.y);
      cctx.rotate(p.rot);
      const hue = (p.x/confetti.width*360 + elapsed*60) % 360;
      cctx.fillStyle = `hsl(${hue}, 90%, 60%)`;
      if (p.shape==='rect'){
        cctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
      } else {
        cctx.beginPath(); cctx.arc(0,0,p.size/2,0,Math.PI*2); cctx.fill();
      }
      cctx.restore();
    });
  }

  // ----- Utils -----
  function mk(tag,cls,txt){ const el=document.createElement(tag); if(cls) el.className=cls; if(txt!=null) el.textContent=txt; return el; }
  function clamp(n,min,max){ return Math.min(max,Math.max(min,n)); }
  function csvEscape(s){ return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s; }
  function downloadBlob(content, name, type){
    const blob = new Blob([content], {type}); const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=name; a.click(); URL.revokeObjectURL(url);
  }

  // ----- Boot -----
  function init(){
    const url = new URL(location.href);
    for(let i=1;i<=NUM_PLAYERS;i++){
      const v=url.searchParams.get('p'+i); if(v) INIT_NAMES[i-1]=decodeURIComponent(v);
    }
    state.players = Array.from({length:NUM_PLAYERS},(_,i)=>({name:INIT_NAMES[i], pos:0, animX:startLineX(), y:null, baseY:null}));
    buildNameEditor(); buildRoundInputs();
    elTotalRounds.value = state.totalRounds;
    elRoundHud.textContent = `Round ${state.roundNow}/${state.totalRounds}`;
    resize();
    lastFrame=performance.now();
    requestAnimationFrame(loop);
  }
  window.addEventListener('resize', resize);

  // timer text init
  function tickClock(){ /* handled by start/stop */ }

  init();
})();
</script>
</body>
</html>
